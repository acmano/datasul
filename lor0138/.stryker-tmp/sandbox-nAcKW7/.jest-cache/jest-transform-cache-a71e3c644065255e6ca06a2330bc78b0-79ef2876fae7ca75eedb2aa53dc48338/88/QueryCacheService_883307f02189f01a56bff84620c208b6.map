{"file":"/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-nAcKW7/src/shared/utils/cache/QueryCacheService.ts","mappings":";AAAA,cAAc;AACd,8CAA8C;;;;;;AAE9C,oDAA4B;AAC5B,kDAA+C;AAC/C,sCAAgC;AAShC;;;GAGG;AACH,MAAa,iBAAiB;IAI5B;;;;;;;;;;;;OAYG;IACH,MAAM,CAAC,KAAK,CAAC,SAAS,CACpB,GAAW,EACX,SAAgB,EAAE,EAClB,OAAyB,EACzB,UAA6B,EAAE;QAE/B,MAAM,EAAE,GAAG,GAAG,IAAI,CAAC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,SAAS,GAAG,KAAK,EAAE,GAAG,OAAO,CAAC;QAE5F,oCAAoC;QACpC,IAAI,SAAS,EAAE,CAAC;YACd,YAAG,CAAC,KAAK,CAAC,mBAAmB,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;YAC3C,OAAO,OAAO,EAAE,CAAC;QACnB,CAAC;QAED,uBAAuB;QACvB,MAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QAE5D,yBAAyB;QACzB,MAAM,MAAM,GAAG,MAAM,2BAAY,CAAC,GAAG,CAAI,QAAQ,CAAC,CAAC;QACnD,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YACzB,YAAG,CAAC,KAAK,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;YACzD,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,uBAAuB;QACvB,YAAG,CAAC,KAAK,CAAC,mBAAmB,EAAE,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;QAC1D,MAAM,MAAM,GAAG,MAAM,OAAO,EAAE,CAAC;QAE/B,qBAAqB;QACrB,MAAM,2BAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;QAE9C,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACK,MAAM,CAAC,gBAAgB,CAAC,GAAW,EAAE,MAAa,EAAE,MAAc;QACxE,0CAA0C;QAC1C,MAAM,aAAa,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;QAEtD,wDAAwD;QACxD,uDAAuD;QACvD,IAAI,SAAiB,CAAC;QAEtB,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;YAC1B,2DAA2D;YAC3D,MAAM,YAAY,GAAG,MAAM;iBACxB,GAAG,CAAC,CAAC,CAAC,EAAE;gBACP,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;oBACxC,+CAA+C;oBAC/C,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC;gBAC1C,CAAC;gBACD,OAAO,CAAC,CAAC;YACX,CAAC,CAAC;iBACD,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACb,6BAA6B;gBAC7B,MAAM,KAAK,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE,CAAC;gBAC5B,MAAM,KAAK,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE,CAAC;gBAC5B,OAAO,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YACpC,CAAC,CAAC,CAAC;YAEL,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QAC3C,CAAC;aAAM,CAAC;YACN,sBAAsB;YACtB,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;QACjE,CAAC;QAED,aAAa;QACb,MAAM,IAAI,GAAG,gBAAM;aAChB,UAAU,CAAC,KAAK,CAAC;aACjB,MAAM,CAAC,GAAG,aAAa,IAAI,SAAS,EAAE,CAAC;aACvC,MAAM,CAAC,KAAK,CAAC;aACb,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,wBAAwB;QAE7C,OAAO,GAAG,MAAM,IAAI,IAAI,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;;;;;;;OAWG;IACH,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,OAAe;QACrC,YAAG,CAAC,IAAI,CAAC,yBAAyB,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;QACjD,OAAO,2BAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,QAAkB;QAChD,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,KAAK,IAAI,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC1C,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,aAAa,CACxB,GAAW,EACX,MAAa,EACb,OAAyB,EACzB,GAAY;QAEZ,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE;YAC1C,GAAG,EAAE,GAAG,IAAI,GAAG,EAAE,wBAAwB;YACzC,MAAM,EAAE,MAAM;SACf,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,wBAAwB,CACnC,GAAW,EACX,MAAa,EACb,OAAyB,EACzB,GAAY;QAEZ,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE;YAC1C,GAAG,EAAE,GAAG,IAAI,GAAG,EAAE,mCAAmC;YACpD,MAAM,EAAE,iBAAiB;SAC1B,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,eAAe,CAC1B,GAAW,EACX,MAAa,EACb,OAAyB;QAEzB,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE;YAC1C,GAAG,EAAE,EAAE,EAAE,cAAc;YACvB,MAAM,EAAE,QAAQ;SACjB,CAAC,CAAC;IACL,CAAC;;AAxKH,8CAyKC;AAxKyB,6BAAW,GAAG,GAAG,CAAC,CAAC,YAAY;AAC/B,gCAAc,GAAG,OAAO,CAAC","names":[],"sources":["/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-nAcKW7/src/shared/utils/cache/QueryCacheService.ts"],"sourcesContent":["// @ts-nocheck\n// src/shared/utils/cache/QueryCacheService.ts\n\nimport crypto from 'crypto';\nimport { CacheManager } from '../cacheManager';\nimport { log } from '../logger';\n\nexport interface QueryCacheOptions {\n  ttl?: number; // TTL específico em segundos\n  prefix?: string; // Prefixo da chave de cache\n  skipCache?: boolean; // Pular cache para esta query\n  invalidatePattern?: string; // Pattern para invalidar\n}\n\n/**\n * Serviço de cache para queries de banco de dados\n * Gera keys automáticas baseadas em hash(SQL + params)\n */\nexport class QueryCacheService {\n  private static readonly DEFAULT_TTL = 300; // 5 minutos\n  private static readonly DEFAULT_PREFIX = 'query';\n\n  /**\n   * Executa query com cache\n   * \n   * @example\n   * ```typescript\n   * const result = await QueryCacheService.withCache(\n   *   'SELECT * FROM item WHERE codigo = @p1',\n   *   [{ name: 'p1', value: '7530110' }],\n   *   async () => DatabaseManager.queryEmpWithParams(sql, params),\n   *   { ttl: 600, prefix: 'item' }\n   * );\n   * ```\n   */\n  static async withCache<T>(\n    sql: string,\n    params: any[] = [],\n    queryFn: () => Promise<T>,\n    options: QueryCacheOptions = {}\n  ): Promise<T> {\n    const { ttl = this.DEFAULT_TTL, prefix = this.DEFAULT_PREFIX, skipCache = false } = options;\n\n    // Se skip explícito, executa direto\n    if (skipCache) {\n      log.debug('Query cache: SKIP', { prefix });\n      return queryFn();\n    }\n\n    // Gerar chave de cache\n    const cacheKey = this.generateCacheKey(sql, params, prefix);\n\n    // Tentar buscar do cache\n    const cached = await CacheManager.get<T>(cacheKey);\n    if (cached !== undefined) {\n      log.debug('Query cache: HIT', { key: cacheKey, prefix });\n      return cached;\n    }\n\n    // MISS: executar query\n    log.debug('Query cache: MISS', { key: cacheKey, prefix });\n    const result = await queryFn();\n\n    // Armazenar no cache\n    await CacheManager.set(cacheKey, result, ttl);\n\n    return result;\n  }\n\n  /**\n   * Gera chave de cache determinística\n   * Hash MD5 de: prefix:sql:params_json\n   * \n   * ✅ CORRIGIDO: Serializa params corretamente (array ou objeto)\n   */\n  private static generateCacheKey(sql: string, params: any[], prefix: string): string {\n    // Normalizar SQL (remover espaços extras)\n    const normalizedSql = sql.replace(/\\s+/g, ' ').trim();\n\n    // ✅ CORREÇÃO: Serializar params de forma determinística\n    // Se for array, mapeia para extrair valores relevantes\n    let paramsStr: string;\n    \n    if (Array.isArray(params)) {\n      // Para array de QueryParameter: [{name, type, value}, ...]\n      const sortedParams = params\n        .map(p => {\n          if (typeof p === 'object' && p !== null) {\n            // Extrai apenas name e value, ordena as chaves\n            return { name: p.name, value: p.value };\n          }\n          return p;\n        })\n        .sort((a, b) => {\n          // Ordena por name se existir\n          const nameA = a?.name || '';\n          const nameB = b?.name || '';\n          return nameA.localeCompare(nameB);\n        });\n      \n      paramsStr = JSON.stringify(sortedParams);\n    } else {\n      // Para objeto simples\n      paramsStr = JSON.stringify(params, Object.keys(params).sort());\n    }\n\n    // Gerar hash\n    const hash = crypto\n      .createHash('md5')\n      .update(`${normalizedSql}:${paramsStr}`)\n      .digest('hex')\n      .substring(0, 16); // 16 chars é suficiente\n\n    return `${prefix}:${hash}`;\n  }\n\n  /**\n   * Invalida cache por pattern\n   * \n   * @example\n   * ```typescript\n   * // Invalidar todos os caches de item\n   * await QueryCacheService.invalidate('item:*');\n   * \n   * // Invalidar cache específico\n   * await QueryCacheService.invalidate('item:abc123def456');\n   * ```\n   */\n  static async invalidate(pattern: string): Promise<number> {\n    log.info('Query cache: INVALIDATE', { pattern });\n    return CacheManager.delete(pattern);\n  }\n\n  /**\n   * Invalida múltiplos patterns\n   */\n  static async invalidateMultiple(patterns: string[]): Promise<number> {\n    let total = 0;\n    for (const pattern of patterns) {\n      total += await this.invalidate(pattern);\n    }\n    return total;\n  }\n\n  /**\n   * Wrapper para queries de itens\n   */\n  static async withItemCache<T>(\n    sql: string,\n    params: any[],\n    queryFn: () => Promise<T>,\n    ttl?: number\n  ): Promise<T> {\n    return this.withCache(sql, params, queryFn, {\n      ttl: ttl || 600, // 10 minutos para itens\n      prefix: 'item',\n    });\n  }\n\n  /**\n   * Wrapper para queries de estabelecimentos\n   */\n  static async withEstabelecimentoCache<T>(\n    sql: string,\n    params: any[],\n    queryFn: () => Promise<T>,\n    ttl?: number\n  ): Promise<T> {\n    return this.withCache(sql, params, queryFn, {\n      ttl: ttl || 900, // 15 minutos para estabelecimentos\n      prefix: 'estabelecimento',\n    });\n  }\n\n  /**\n   * Wrapper para queries de health check (TTL curto)\n   */\n  static async withHealthCache<T>(\n    sql: string,\n    params: any[],\n    queryFn: () => Promise<T>\n  ): Promise<T> {\n    return this.withCache(sql, params, queryFn, {\n      ttl: 30, // 30 segundos\n      prefix: 'health',\n    });\n  }\n}"],"version":3}