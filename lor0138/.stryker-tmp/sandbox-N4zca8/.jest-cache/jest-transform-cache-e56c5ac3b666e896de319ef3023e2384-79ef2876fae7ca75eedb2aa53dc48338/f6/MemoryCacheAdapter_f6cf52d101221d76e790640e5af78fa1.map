{"file":"/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-N4zca8/src/shared/utils/cache/MemoryCacheAdapter.ts","mappings":"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","names":[],"sources":["/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-N4zca8/src/shared/utils/cache/MemoryCacheAdapter.ts"],"sourcesContent":["// @ts-nocheck\n// src/shared/utils/cache/MemoryCacheAdapter.ts\n\nimport NodeCache from 'node-cache';\nimport { CacheAdapter } from './CacheAdapter';\nimport { log } from '../logger';\n\n/**\n * Adaptador de cache em memória (L1)\n * - Ultra rápido (acesso local)\n * - Volátil (perde dados ao reiniciar)\n * - Não compartilhado entre instâncias\n */\nexport class MemoryCacheAdapter implements CacheAdapter {\n  private cache: NodeCache;\n  private name: string;\n\n  constructor(stdTTL: number = 300, name: string = 'L1-Memory') {\n    this.cache = new NodeCache({ \n      stdTTL,\n      checkperiod: 120, // Verifica expiração a cada 2min\n      useClones: false  // Performance: não clona objetos\n    });\n    this.name = name;\n\n    log.info(`${this.name} cache inicializado`, { \n      ttl: stdTTL,\n      checkPeriod: 120 \n    });\n  }\n\n  async get<T>(key: string): Promise<T | undefined> {\n    try {\n      const value = this.cache.get<T>(key);\n      \n      if (value !== undefined) {\n        log.debug(`${this.name} HIT`, { key });\n      } else {\n        log.debug(`${this.name} MISS`, { key });\n      }\n\n      return value;\n    } catch (error) {\n      log.error(`${this.name} GET error`, { key, error });\n      return undefined;\n    }\n  }\n\n  async set<T>(key: string, value: T, ttl?: number): Promise<boolean> {\n    try {\n      const success = ttl \n        ? this.cache.set(key, value, ttl)\n        : this.cache.set(key, value);\n\n      if (success) {\n        log.debug(`${this.name} SET`, { key, ttl });\n      }\n\n      return success;\n    } catch (error) {\n      log.error(`${this.name} SET error`, { key, error });\n      return false;\n    }\n  }\n\n  async delete(key: string): Promise<number> {\n    try {\n      const deleted = this.cache.del(key);\n      log.debug(`${this.name} DELETE`, { key, deleted });\n      return deleted;\n    } catch (error) {\n      log.error(`${this.name} DELETE error`, { key, error });\n      return 0;\n    }\n  }\n\n  async flush(): Promise<void> {\n    try {\n      this.cache.flushAll();\n      log.info(`${this.name} FLUSH ALL`);\n    } catch (error) {\n      log.error(`${this.name} FLUSH error`, { error });\n    }\n  }\n\n  async keys(pattern?: string): Promise<string[]> {\n    try {\n      const allKeys = this.cache.keys();\n\n      if (!pattern) {\n        return allKeys;\n      }\n\n      // Converte pattern com * para regex\n      const regex = new RegExp(\n        '^' + pattern.replace(/\\*/g, '.*') + '$'\n      );\n\n      return allKeys.filter(key => regex.test(key));\n    } catch (error) {\n      log.error(`${this.name} KEYS error`, { pattern, error });\n      return [];\n    }\n  }\n\n  async isReady(): Promise<boolean> {\n    return true; // Memória sempre está pronta\n  }\n\n  async close(): Promise<void> {\n    try {\n      this.cache.close();\n      log.info(`${this.name} fechado`);\n    } catch (error) {\n      log.error(`${this.name} CLOSE error`, { error });\n    }\n  }\n\n  /**\n   * Métodos extras específicos do NodeCache\n   */\n  getStats() {\n    return this.cache.getStats();\n  }\n\n  getTtl(key: string): number | undefined {\n    return this.cache.getTtl(key);\n  }\n}"],"version":3}