dfee2bba158048eb387b4bef2fff8ca5
"use strict";
// src/shared/utils/retry.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryWithBackoff = retryWithBackoff;
exports.isRetryableError = isRetryableError;
exports.retryOnRetryableError = retryOnRetryableError;
const logger_1 = require("./logger");
const DEFAULT_OPTIONS = {
    maxAttempts: 3,
    initialDelay: 1000,
    maxDelay: 10000,
    backoffFactor: 2,
    jitter: true,
};
/**
 * Executa uma função com retry e exponential backoff
 *
 * @param fn Função async a ser executada
 * @param options Opções de retry
 * @param context Contexto para logs (ex: "SQL Server EMP")
 * @returns Resultado da função ou lança erro após todas as tentativas
 *
 * @example
 * ```typescript
 * const result = await retryWithBackoff(
 *   () => pool.connect(),
 *   { maxAttempts: 5, initialDelay: 1000 },
 *   'SQL Server Connection'
 * );
 * ```
 */
async function retryWithBackoff(fn, options = {}, context = 'Operation') {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let lastError = null;
    let delay = opts.initialDelay;
    for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {
        try {
            logger_1.log.debug(`${context}: Tentativa ${attempt}/${opts.maxAttempts}`, {
                attempt,
                maxAttempts: opts.maxAttempts,
            });
            const result = await fn();
            if (attempt > 1) {
                logger_1.log.info(`${context}: Sucesso na tentativa ${attempt}`, { attempt });
            }
            return result;
        }
        catch (error) {
            lastError = error;
            if (attempt === opts.maxAttempts) {
                logger_1.log.error(`${context}: Falhou após ${opts.maxAttempts} tentativas`, {
                    error: lastError.message,
                    attempts: opts.maxAttempts,
                });
                throw lastError;
            }
            // Calcular próximo delay com exponential backoff
            const nextDelay = calculateDelay(delay, opts);
            logger_1.log.warn(`${context}: Tentativa ${attempt} falhou, retry em ${nextDelay}ms`, {
                attempt,
                error: lastError.message,
                nextDelay,
                nextAttempt: attempt + 1,
            });
            // Callback opcional
            if (opts.onRetry) {
                opts.onRetry(lastError, attempt, nextDelay);
            }
            // Aguardar antes do próximo retry
            await sleep(nextDelay);
            // Atualizar delay para próxima iteração
            delay = Math.min(delay * opts.backoffFactor, opts.maxDelay);
        }
    }
    // Nunca deve chegar aqui, mas TypeScript precisa
    throw lastError || new Error(`${context}: Retry failed`);
}
/**
 * Calcula delay com exponential backoff e jitter opcional
 */
function calculateDelay(currentDelay, options) {
    let nextDelay = currentDelay;
    // Adicionar jitter (aleatoriedade) se habilitado
    if (options.jitter) {
        // Jitter entre 50% e 150% do delay
        const jitterFactor = 0.5 + Math.random();
        nextDelay = Math.floor(currentDelay * jitterFactor);
    }
    // Garantir que não excede maxDelay
    return Math.min(nextDelay, options.maxDelay);
}
/**
 * Helper para aguardar um tempo
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
/**
 * Verifica se um erro é retryable (temporário)
 */
function isRetryableError(error) {
    const retryablePatterns = [
        /ECONNREFUSED/i,
        /ETIMEDOUT/i,
        /ENOTFOUND/i,
        /EHOSTUNREACH/i,
        /ENETUNREACH/i,
        /timeout/i,
        /connection.*closed/i,
        /connection.*reset/i,
        /socket hang up/i,
    ];
    const errorMessage = error.message || '';
    return retryablePatterns.some(pattern => pattern.test(errorMessage));
}
/**
 * Retry apenas para erros retryable
 */
async function retryOnRetryableError(fn, options = {}, context = 'Operation') {
    return retryWithBackoff(fn, {
        ...options,
        onRetry: (error, attempt, delay) => {
            // Só retry se for erro retryable
            if (!isRetryableError(error)) {
                throw error; // Lança imediatamente se não for retryable
            }
            options.onRetry?.(error, attempt, delay);
        },
    }, context);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWFuby9wcm9qZXRvcy9kYXRhc3VsL2xvcjAxMzgvc3JjL3NoYXJlZC91dGlscy9yZXRyeS50cyIsIm1hcHBpbmdzIjoiO0FBQUEsNEJBQTRCOztBQXNDNUIsNENBMkRDO0FBNkJELDRDQWVDO0FBS0Qsc0RBbUJDO0FBbktELHFDQUErQjtBQVcvQixNQUFNLGVBQWUsR0FBaUI7SUFDcEMsV0FBVyxFQUFFLENBQUM7SUFDZCxZQUFZLEVBQUUsSUFBSTtJQUNsQixRQUFRLEVBQUUsS0FBSztJQUNmLGFBQWEsRUFBRSxDQUFDO0lBQ2hCLE1BQU0sRUFBRSxJQUFJO0NBQ2IsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0ksS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxFQUFvQixFQUNwQixVQUFpQyxFQUFFLEVBQ25DLFVBQWtCLFdBQVc7SUFFN0IsTUFBTSxJQUFJLEdBQUcsRUFBRSxHQUFHLGVBQWUsRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFDO0lBQ2hELElBQUksU0FBUyxHQUFpQixJQUFJLENBQUM7SUFDbkMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUU5QixLQUFLLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBQzdELElBQUksQ0FBQztZQUNILFlBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLGVBQWUsT0FBTyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDaEUsT0FBTztnQkFDUCxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7YUFDOUIsQ0FBQyxDQUFDO1lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUUxQixJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDaEIsWUFBRyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sMEJBQTBCLE9BQU8sRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENB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QyxFQUFvQixFQUNwQixVQUFpQyxFQUFFLEVBQ25DLFVBQWtCLFdBQVc7SUFFN0IsT0FBTyxnQkFBZ0IsQ0FDckIsRUFBRSxFQUNGO1FBQ0UsR0FBRyxPQUFPO1FBQ1YsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUNqQyxpQ0FBaUM7WUFDakMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzdCLE1BQU0sS0FBSyxDQUFDLENBQUMsMkNBQTJDO1lBQzFELENBQUM7WUFDRCxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDO0tBQ0YsRUFDRCxPQUFPLENBQ1IsQ0FBQztBQUNKLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWFuby9wcm9qZXRvcy9kYXRhc3VsL2xvcjAxMzgvc3JjL3NoYXJlZC91dGlscy9yZXRyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc2hhcmVkL3V0aWxzL3JldHJ5LnRzXG5cbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXRyeU9wdGlvbnMge1xuICBtYXhBdHRlbXB0czogbnVtYmVyO1xuICBpbml0aWFsRGVsYXk6IG51bWJlcjsgLy8gbXNcbiAgbWF4RGVsYXk6IG51bWJlcjsgLy8gbXNcbiAgYmFja29mZkZhY3RvcjogbnVtYmVyOyAvLyBtdWx0aXBsaWNhZG9yIHBhcmEgZXhwb25lbnRpYWwgYmFja29mZlxuICBqaXR0ZXI6IGJvb2xlYW47IC8vIGFkaWNpb25hIGFsZWF0b3JpZWRhZGUgcGFyYSBldml0YXIgdGh1bmRlcmluZyBoZXJkXG4gIG9uUmV0cnk/OiAoZXJyb3I6IEVycm9yLCBhdHRlbXB0OiBudW1iZXIsIG5leHREZWxheTogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IFJldHJ5T3B0aW9ucyA9IHtcbiAgbWF4QXR0ZW1wdHM6IDMsXG4gIGluaXRpYWxEZWxheTogMTAwMCxcbiAgbWF4RGVsYXk6IDEwMDAwLFxuICBiYWNrb2ZmRmFjdG9yOiAyLFxuICBqaXR0ZXI6IHRydWUsXG59O1xuXG4vKipcbiAqIEV4ZWN1dGEgdW1hIGZ1bsOnw6NvIGNvbSByZXRyeSBlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIFxuICogQHBhcmFtIGZuIEZ1bsOnw6NvIGFzeW5jIGEgc2VyIGV4ZWN1dGFkYVxuICogQHBhcmFtIG9wdGlvbnMgT3DDp8O1ZXMgZGUgcmV0cnlcbiAqIEBwYXJhbSBjb250ZXh0IENvbnRleHRvIHBhcmEgbG9ncyAoZXg6IFwiU1FMIFNlcnZlciBFTVBcIilcbiAqIEByZXR1cm5zIFJlc3VsdGFkbyBkYSBmdW7Dp8OjbyBvdSBsYW7Dp2EgZXJybyBhcMOzcyB0b2RhcyBhcyB0ZW50YXRpdmFzXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKFxuICogICAoKSA9PiBwb29sLmNvbm5lY3QoKSxcbiAqICAgeyBtYXhBdHRlbXB0czogNSwgaW5pdGlhbERlbGF5OiAxMDAwIH0sXG4gKiAgICdTUUwgU2VydmVyIENvbm5lY3Rpb24nXG4gKiApO1xuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeVdpdGhCYWNrb2ZmPFQ+KFxuICBmbjogKCkgPT4gUHJvbWlzZTxUPixcbiAgb3B0aW9uczogUGFydGlhbDxSZXRyeU9wdGlvbnM+ID0ge30sXG4gIGNvbnRleHQ6IHN0cmluZyA9ICdPcGVyYXRpb24nXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3Qgb3B0cyA9IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gIGxldCBkZWxheSA9IG9wdHMuaW5pdGlhbERlbGF5O1xuXG4gIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG9wdHMubWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgIHRyeSB7XG4gICAgICBsb2cuZGVidWcoYCR7Y29udGV4dH06IFRlbnRhdGl2YSAke2F0dGVtcHR9LyR7b3B0cy5tYXhBdHRlbXB0c31gLCB7XG4gICAgICAgIGF0dGVtcHQsXG4gICAgICAgIG1heEF0dGVtcHRzOiBvcHRzLm1heEF0dGVtcHRzLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgICBcbiAgICAgIGlmIChhdHRlbXB0ID4gMSkge1xuICAgICAgICBsb2cuaW5mbyhgJHtjb250ZXh0fTogU3VjZXNzbyBuYSB0ZW50YXRpdmEgJHthdHRlbXB0fWAsIHsgYXR0ZW1wdCB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG5cbiAgICAgIGlmIChhdHRlbXB0ID09PSBvcHRzLm1heEF0dGVtcHRzKSB7XG4gICAgICAgIGxvZy5lcnJvcihgJHtjb250ZXh0fTogRmFsaG91IGFww7NzICR7b3B0cy5tYXhBdHRlbXB0c30gdGVudGF0aXZhc2AsIHtcbiAgICAgICAgICBlcnJvcjogbGFzdEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgYXR0ZW1wdHM6IG9wdHMubWF4QXR0ZW1wdHMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGFyIHByw7N4aW1vIGRlbGF5IGNvbSBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICBjb25zdCBuZXh0RGVsYXkgPSBjYWxjdWxhdGVEZWxheShkZWxheSwgb3B0cyk7XG4gICAgICBcbiAgICAgIGxvZy53YXJuKGAke2NvbnRleHR9OiBUZW50YXRpdmEgJHthdHRlbXB0fSBmYWxob3UsIHJldHJ5IGVtICR7bmV4dERlbGF5fW1zYCwge1xuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBlcnJvcjogbGFzdEVycm9yLm1lc3NhZ2UsXG4gICAgICAgIG5leHREZWxheSxcbiAgICAgICAgbmV4dEF0dGVtcHQ6IGF0dGVtcHQgKyAxLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGxiYWNrIG9wY2lvbmFsXG4gICAgICBpZiAob3B0cy5vblJldHJ5KSB7XG4gICAgICAgIG9wdHMub25SZXRyeShsYXN0RXJyb3IsIGF0dGVtcHQsIG5leHREZWxheSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFndWFyZGFyIGFudGVzIGRvIHByw7N4aW1vIHJldHJ5XG4gICAgICBhd2FpdCBzbGVlcChuZXh0RGVsYXkpO1xuXG4gICAgICAvLyBBdHVhbGl6YXIgZGVsYXkgcGFyYSBwcsOzeGltYSBpdGVyYcOnw6NvXG4gICAgICBkZWxheSA9IE1hdGgubWluKGRlbGF5ICogb3B0cy5iYWNrb2ZmRmFjdG9yLCBvcHRzLm1heERlbGF5KTtcbiAgICB9XG4gIH1cblxuICAvLyBOdW5jYSBkZXZlIGNoZWdhciBhcXVpLCBtYXMgVHlwZVNjcmlwdCBwcmVjaXNhXG4gIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoYCR7Y29udGV4dH06IFJldHJ5IGZhaWxlZGApO1xufVxuXG4vKipcbiAqIENhbGN1bGEgZGVsYXkgY29tIGV4cG9uZW50aWFsIGJhY2tvZmYgZSBqaXR0ZXIgb3BjaW9uYWxcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsYXkoY3VycmVudERlbGF5OiBudW1iZXIsIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyk6IG51bWJlciB7XG4gIGxldCBuZXh0RGVsYXkgPSBjdXJyZW50RGVsYXk7XG5cbiAgLy8gQWRpY2lvbmFyIGppdHRlciAoYWxlYXRvcmllZGFkZSkgc2UgaGFiaWxpdGFkb1xuICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAvLyBKaXR0ZXIgZW50cmUgNTAlIGUgMTUwJSBkbyBkZWxheVxuICAgIGNvbnN0IGppdHRlckZhY3RvciA9IDAuNSArIE1hdGgucmFuZG9tKCk7XG4gICAgbmV4dERlbGF5ID0gTWF0aC5mbG9vcihjdXJyZW50RGVsYXkgKiBqaXR0ZXJGYWN0b3IpO1xuICB9XG5cbiAgLy8gR2FyYW50aXIgcXVlIG7Do28gZXhjZWRlIG1heERlbGF5XG4gIHJldHVybiBNYXRoLm1pbihuZXh0RGVsYXksIG9wdGlvbnMubWF4RGVsYXkpO1xufVxuXG4vKipcbiAqIEhlbHBlciBwYXJhIGFndWFyZGFyIHVtIHRlbXBvXG4gKi9cbmZ1bmN0aW9uIHNsZWVwKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIFZlcmlmaWNhIHNlIHVtIGVycm8gw6kgcmV0cnlhYmxlICh0ZW1wb3LDoXJpbylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmV0cnlhYmxlRXJyb3IoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJldHJ5YWJsZVBhdHRlcm5zID0gW1xuICAgIC9FQ09OTlJFRlVTRUQvaSxcbiAgICAvRVRJTUVET1VUL2ksXG4gICAgL0VOT1RGT1VORC9pLFxuICAgIC9FSE9TVFVOUkVBQ0gvaSxcbiAgICAvRU5FVFVOUkVBQ0gvaSxcbiAgICAvdGltZW91dC9pLFxuICAgIC9jb25uZWN0aW9uLipjbG9zZWQvaSxcbiAgICAvY29ubmVjdGlvbi4qcmVzZXQvaSxcbiAgICAvc29ja2V0IGhhbmcgdXAvaSxcbiAgXTtcblxuICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8ICcnO1xuICByZXR1cm4gcmV0cnlhYmxlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChlcnJvck1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXRyeSBhcGVuYXMgcGFyYSBlcnJvcyByZXRyeWFibGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldHJ5T25SZXRyeWFibGVFcnJvcjxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIG9wdGlvbnM6IFBhcnRpYWw8UmV0cnlPcHRpb25zPiA9IHt9LFxuICBjb250ZXh0OiBzdHJpbmcgPSAnT3BlcmF0aW9uJ1xuKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiByZXRyeVdpdGhCYWNrb2ZmKFxuICAgIGZuLFxuICAgIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBvblJldHJ5OiAoZXJyb3IsIGF0dGVtcHQsIGRlbGF5KSA9PiB7XG4gICAgICAgIC8vIFPDsyByZXRyeSBzZSBmb3IgZXJybyByZXRyeWFibGVcbiAgICAgICAgaWYgKCFpc1JldHJ5YWJsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yOyAvLyBMYW7Dp2EgaW1lZGlhdGFtZW50ZSBzZSBuw6NvIGZvciByZXRyeWFibGVcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm9uUmV0cnk/LihlcnJvciwgYXR0ZW1wdCwgZGVsYXkpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGNvbnRleHRcbiAgKTtcbn0iXSwidmVyc2lvbiI6M30=