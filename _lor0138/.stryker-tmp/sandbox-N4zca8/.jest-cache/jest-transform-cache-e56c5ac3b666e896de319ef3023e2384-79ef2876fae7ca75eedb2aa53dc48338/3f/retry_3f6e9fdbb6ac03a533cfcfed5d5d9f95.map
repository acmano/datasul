{"file":"/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-N4zca8/src/shared/utils/retry.ts","mappings":"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","names":[],"sources":["/home/mano/projetos/datasul/lor0138/.stryker-tmp/sandbox-N4zca8/src/shared/utils/retry.ts"],"sourcesContent":["// @ts-nocheck\n// src/shared/utils/retry.ts\n\nimport { log } from './logger';\n\nexport interface RetryOptions {\n  maxAttempts: number;\n  initialDelay: number; // ms\n  maxDelay: number; // ms\n  backoffFactor: number; // multiplicador para exponential backoff\n  jitter: boolean; // adiciona aleatoriedade para evitar thundering herd\n  onRetry?: (error: Error, attempt: number, nextDelay: number) => void;\n}\n\nconst DEFAULT_OPTIONS: RetryOptions = {\n  maxAttempts: 3,\n  initialDelay: 1000,\n  maxDelay: 10000,\n  backoffFactor: 2,\n  jitter: true,\n};\n\n/**\n * Executa uma função com retry e exponential backoff\n * \n * @param fn Função async a ser executada\n * @param options Opções de retry\n * @param context Contexto para logs (ex: \"SQL Server EMP\")\n * @returns Resultado da função ou lança erro após todas as tentativas\n * \n * @example\n * ```typescript\n * const result = await retryWithBackoff(\n *   () => pool.connect(),\n *   { maxAttempts: 5, initialDelay: 1000 },\n *   'SQL Server Connection'\n * );\n * ```\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: Partial<RetryOptions> = {},\n  context: string = 'Operation'\n): Promise<T> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  let lastError: Error | null = null;\n  let delay = opts.initialDelay;\n\n  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\n    try {\n      log.debug(`${context}: Tentativa ${attempt}/${opts.maxAttempts}`, {\n        attempt,\n        maxAttempts: opts.maxAttempts,\n      });\n\n      const result = await fn();\n      \n      if (attempt > 1) {\n        log.info(`${context}: Sucesso na tentativa ${attempt}`, { attempt });\n      }\n      \n      return result;\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === opts.maxAttempts) {\n        log.error(`${context}: Falhou após ${opts.maxAttempts} tentativas`, {\n          error: lastError.message,\n          attempts: opts.maxAttempts,\n        });\n        throw lastError;\n      }\n\n      // Calcular próximo delay com exponential backoff\n      const nextDelay = calculateDelay(delay, opts);\n      \n      log.warn(`${context}: Tentativa ${attempt} falhou, retry em ${nextDelay}ms`, {\n        attempt,\n        error: lastError.message,\n        nextDelay,\n        nextAttempt: attempt + 1,\n      });\n\n      // Callback opcional\n      if (opts.onRetry) {\n        opts.onRetry(lastError, attempt, nextDelay);\n      }\n\n      // Aguardar antes do próximo retry\n      await sleep(nextDelay);\n\n      // Atualizar delay para próxima iteração\n      delay = Math.min(delay * opts.backoffFactor, opts.maxDelay);\n    }\n  }\n\n  // Nunca deve chegar aqui, mas TypeScript precisa\n  throw lastError || new Error(`${context}: Retry failed`);\n}\n\n/**\n * Calcula delay com exponential backoff e jitter opcional\n */\nfunction calculateDelay(currentDelay: number, options: RetryOptions): number {\n  let nextDelay = currentDelay;\n\n  // Adicionar jitter (aleatoriedade) se habilitado\n  if (options.jitter) {\n    // Jitter entre 50% e 150% do delay\n    const jitterFactor = 0.5 + Math.random();\n    nextDelay = Math.floor(currentDelay * jitterFactor);\n  }\n\n  // Garantir que não excede maxDelay\n  return Math.min(nextDelay, options.maxDelay);\n}\n\n/**\n * Helper para aguardar um tempo\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Verifica se um erro é retryable (temporário)\n */\nexport function isRetryableError(error: Error): boolean {\n  const retryablePatterns = [\n    /ECONNREFUSED/i,\n    /ETIMEDOUT/i,\n    /ENOTFOUND/i,\n    /EHOSTUNREACH/i,\n    /ENETUNREACH/i,\n    /timeout/i,\n    /connection.*closed/i,\n    /connection.*reset/i,\n    /socket hang up/i,\n  ];\n\n  const errorMessage = error.message || '';\n  return retryablePatterns.some(pattern => pattern.test(errorMessage));\n}\n\n/**\n * Retry apenas para erros retryable\n */\nexport async function retryOnRetryableError<T>(\n  fn: () => Promise<T>,\n  options: Partial<RetryOptions> = {},\n  context: string = 'Operation'\n): Promise<T> {\n  return retryWithBackoff(\n    fn,\n    {\n      ...options,\n      onRetry: (error, attempt, delay) => {\n        // Só retry se for erro retryable\n        if (!isRetryableError(error)) {\n          throw error; // Lança imediatamente se não for retryable\n        }\n        options.onRetry?.(error, attempt, delay);\n      },\n    },\n    context\n  );\n}"],"version":3}