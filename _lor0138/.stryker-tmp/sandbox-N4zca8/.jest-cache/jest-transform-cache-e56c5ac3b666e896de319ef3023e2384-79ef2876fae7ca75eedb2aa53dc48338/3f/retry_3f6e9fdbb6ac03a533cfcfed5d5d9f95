8a6f9e6465ff5c947af9b7ca76bd1b52
"use strict";
// @ts-nocheck
// src/shared/utils/retry.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryWithBackoff = retryWithBackoff;
exports.isRetryableError = isRetryableError;
exports.retryOnRetryableError = retryOnRetryableError;
const logger_1 = require("./logger");
const DEFAULT_OPTIONS = {
    maxAttempts: 3,
    initialDelay: 1000,
    maxDelay: 10000,
    backoffFactor: 2,
    jitter: true,
};
/**
 * Executa uma função com retry e exponential backoff
 *
 * @param fn Função async a ser executada
 * @param options Opções de retry
 * @param context Contexto para logs (ex: "SQL Server EMP")
 * @returns Resultado da função ou lança erro após todas as tentativas
 *
 * @example
 * ```typescript
 * const result = await retryWithBackoff(
 *   () => pool.connect(),
 *   { maxAttempts: 5, initialDelay: 1000 },
 *   'SQL Server Connection'
 * );
 * ```
 */
async function retryWithBackoff(fn, options = {}, context = 'Operation') {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let lastError = null;
    let delay = opts.initialDelay;
    for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {
        try {
            logger_1.log.debug(`${context}: Tentativa ${attempt}/${opts.maxAttempts}`, {
                attempt,
                maxAttempts: opts.maxAttempts,
            });
            const result = await fn();
            if (attempt > 1) {
                logger_1.log.info(`${context}: Sucesso na tentativa ${attempt}`, { attempt });
            }
            return result;
        }
        catch (error) {
            lastError = error;
            if (attempt === opts.maxAttempts) {
                logger_1.log.error(`${context}: Falhou após ${opts.maxAttempts} tentativas`, {
                    error: lastError.message,
                    attempts: opts.maxAttempts,
                });
                throw lastError;
            }
            // Calcular próximo delay com exponential backoff
            const nextDelay = calculateDelay(delay, opts);
            logger_1.log.warn(`${context}: Tentativa ${attempt} falhou, retry em ${nextDelay}ms`, {
                attempt,
                error: lastError.message,
                nextDelay,
                nextAttempt: attempt + 1,
            });
            // Callback opcional
            if (opts.onRetry) {
                opts.onRetry(lastError, attempt, nextDelay);
            }
            // Aguardar antes do próximo retry
            await sleep(nextDelay);
            // Atualizar delay para próxima iteração
            delay = Math.min(delay * opts.backoffFactor, opts.maxDelay);
        }
    }
    // Nunca deve chegar aqui, mas TypeScript precisa
    throw lastError || new Error(`${context}: Retry failed`);
}
/**
 * Calcula delay com exponential backoff e jitter opcional
 */
function calculateDelay(currentDelay, options) {
    let nextDelay = currentDelay;
    // Adicionar jitter (aleatoriedade) se habilitado
    if (options.jitter) {
        // Jitter entre 50% e 150% do delay
        const jitterFactor = 0.5 + Math.random();
        nextDelay = Math.floor(currentDelay * jitterFactor);
    }
    // Garantir que não excede maxDelay
    return Math.min(nextDelay, options.maxDelay);
}
/**
 * Helper para aguardar um tempo
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
/**
 * Verifica se um erro é retryable (temporário)
 */
function isRetryableError(error) {
    const retryablePatterns = [
        /ECONNREFUSED/i,
        /ETIMEDOUT/i,
        /ENOTFOUND/i,
        /EHOSTUNREACH/i,
        /ENETUNREACH/i,
        /timeout/i,
        /connection.*closed/i,
        /connection.*reset/i,
        /socket hang up/i,
    ];
    const errorMessage = error.message || '';
    return retryablePatterns.some(pattern => pattern.test(errorMessage));
}
/**
 * Retry apenas para erros retryable
 */
async function retryOnRetryableError(fn, options = {}, context = 'Operation') {
    return retryWithBackoff(fn, {
        ...options,
        onRetry: (error, attempt, delay) => {
            // Só retry se for erro retryable
            if (!isRetryableError(error)) {
                throw error; // Lança imediatamente se não for retryable
            }
            options.onRetry?.(error, attempt, delay);
        },
    }, context);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWFuby9wcm9qZXRvcy9kYXRhc3VsL2xvcjAxMzgvLnN0cnlrZXItdG1wL3NhbmRib3gtTjR6Y2E4L3NyYy9zaGFyZWQvdXRpbHMvcmV0cnkudHMiLCJtYXBwaW5ncyI6IjtBQUFBLGNBQWM7QUFDZCw0QkFBNEI7O0FBc0M1Qiw0Q0EyREM7QUE2QkQsNENBZUM7QUFLRCxzREFtQkM7QUFuS0QscUNBQStCO0FBVy9CLE1BQU0sZUFBZSxHQUFpQjtJQUNwQyxXQUFXLEVBQUUsQ0FBQztJQUNkLFlBQVksRUFBRSxJQUFJO0lBQ2xCLFFBQVEsRUFBRSxLQUFLO0lBQ2YsYUFBYSxFQUFFLENBQUM7SUFDaEIsTUFBTSxFQUFFLElBQUk7Q0FDYixDQUFDO0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSSxLQUFLLFVBQVUsZ0JBQWdCLENBQ3BDLEVBQW9CLEVBQ3BCLFVBQWlDLEVBQUUsRUFDbkMsVUFBa0IsV0FBVztJQUU3QixNQUFNLElBQUksR0FBRyxFQUFFLEdBQUcsZUFBZSxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUM7SUFDaEQsSUFBSSxTQUFTLEdBQWlCLElBQUksQ0FBQztJQUNuQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBRTlCLEtBQUssSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUM7UUFDN0QsSUFBSSxDQUFDO1lBQ0gsWUFBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLE9BQU8sZUFBZSxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO2dCQUNoRSxPQUFPO2dCQUNQLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVzthQUM5QixDQUFDLENBQUM7WUFFSCxNQUFNLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBRTFCLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUNoQixZQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyww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O0FBRUQ7O0dBRUc7QUFDSSxLQUFLLFVBQVUscUJBQXFCLENBQ3pDLEVBQW9CLEVBQ3BCLFVBQWlDLEVBQUUsRUFDbkMsVUFBa0IsV0FBVztJQUU3QixPQUFPLGdCQUFnQixDQUNyQixFQUFFLEVBQ0Y7UUFDRSxHQUFHLE9BQU87UUFDVixPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ2pDLGlDQUFpQztZQUNqQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDN0IsTUFBTSxLQUFLLENBQUMsQ0FBQywyQ0FBMkM7WUFDMUQsQ0FBQztZQUNELE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzNDLENBQUM7S0FDRixFQUNELE9BQU8sQ0FDUixDQUFDO0FBQ0osQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9tYW5vL3Byb2pldG9zL2RhdGFzdWwvbG9yMDEzOC8uc3RyeWtlci10bXAvc2FuZGJveC1ONHpjYTgvc3JjL3NoYXJlZC91dGlscy9yZXRyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuLy8gc3JjL3NoYXJlZC91dGlscy9yZXRyeS50c1xuXG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlPcHRpb25zIHtcbiAgbWF4QXR0ZW1wdHM6IG51bWJlcjtcbiAgaW5pdGlhbERlbGF5OiBudW1iZXI7IC8vIG1zXG4gIG1heERlbGF5OiBudW1iZXI7IC8vIG1zXG4gIGJhY2tvZmZGYWN0b3I6IG51bWJlcjsgLy8gbXVsdGlwbGljYWRvciBwYXJhIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgaml0dGVyOiBib29sZWFuOyAvLyBhZGljaW9uYSBhbGVhdG9yaWVkYWRlIHBhcmEgZXZpdGFyIHRodW5kZXJpbmcgaGVyZFxuICBvblJldHJ5PzogKGVycm9yOiBFcnJvciwgYXR0ZW1wdDogbnVtYmVyLCBuZXh0RGVsYXk6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBSZXRyeU9wdGlvbnMgPSB7XG4gIG1heEF0dGVtcHRzOiAzLFxuICBpbml0aWFsRGVsYXk6IDEwMDAsXG4gIG1heERlbGF5OiAxMDAwMCxcbiAgYmFja29mZkZhY3RvcjogMixcbiAgaml0dGVyOiB0cnVlLFxufTtcblxuLyoqXG4gKiBFeGVjdXRhIHVtYSBmdW7Dp8OjbyBjb20gcmV0cnkgZSBleHBvbmVudGlhbCBiYWNrb2ZmXG4gKiBcbiAqIEBwYXJhbSBmbiBGdW7Dp8OjbyBhc3luYyBhIHNlciBleGVjdXRhZGFcbiAqIEBwYXJhbSBvcHRpb25zIE9ww6fDtWVzIGRlIHJldHJ5XG4gKiBAcGFyYW0gY29udGV4dCBDb250ZXh0byBwYXJhIGxvZ3MgKGV4OiBcIlNRTCBTZXJ2ZXIgRU1QXCIpXG4gKiBAcmV0dXJucyBSZXN1bHRhZG8gZGEgZnVuw6fDo28gb3UgbGFuw6dhIGVycm8gYXDDs3MgdG9kYXMgYXMgdGVudGF0aXZhc1xuICogXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlXaXRoQmFja29mZihcbiAqICAgKCkgPT4gcG9vbC5jb25uZWN0KCksXG4gKiAgIHsgbWF4QXR0ZW1wdHM6IDUsIGluaXRpYWxEZWxheTogMTAwMCB9LFxuICogICAnU1FMIFNlcnZlciBDb25uZWN0aW9uJ1xuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlXaXRoQmFja29mZjxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIG9wdGlvbnM6IFBhcnRpYWw8UmV0cnlPcHRpb25zPiA9IHt9LFxuICBjb250ZXh0OiBzdHJpbmcgPSAnT3BlcmF0aW9uJ1xuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IG9wdHMgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICBsZXQgZGVsYXkgPSBvcHRzLmluaXRpYWxEZWxheTtcblxuICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBvcHRzLm1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgbG9nLmRlYnVnKGAke2NvbnRleHR9OiBUZW50YXRpdmEgJHthdHRlbXB0fS8ke29wdHMubWF4QXR0ZW1wdHN9YCwge1xuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBtYXhBdHRlbXB0czogb3B0cy5tYXhBdHRlbXB0cyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpO1xuICAgICAgXG4gICAgICBpZiAoYXR0ZW1wdCA+IDEpIHtcbiAgICAgICAgbG9nLmluZm8oYCR7Y29udGV4dH06IFN1Y2Vzc28gbmEgdGVudGF0aXZhICR7YXR0ZW1wdH1gLCB7IGF0dGVtcHQgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuXG4gICAgICBpZiAoYXR0ZW1wdCA9PT0gb3B0cy5tYXhBdHRlbXB0cykge1xuICAgICAgICBsb2cuZXJyb3IoYCR7Y29udGV4dH06IEZhbGhvdSBhcMOzcyAke29wdHMubWF4QXR0ZW1wdHN9IHRlbnRhdGl2YXNgLCB7XG4gICAgICAgICAgZXJyb3I6IGxhc3RFcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGF0dGVtcHRzOiBvcHRzLm1heEF0dGVtcHRzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhciBwcsOzeGltbyBkZWxheSBjb20gZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc3QgbmV4dERlbGF5ID0gY2FsY3VsYXRlRGVsYXkoZGVsYXksIG9wdHMpO1xuICAgICAgXG4gICAgICBsb2cud2FybihgJHtjb250ZXh0fTogVGVudGF0aXZhICR7YXR0ZW1wdH0gZmFsaG91LCByZXRyeSBlbSAke25leHREZWxheX1tc2AsIHtcbiAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgZXJyb3I6IGxhc3RFcnJvci5tZXNzYWdlLFxuICAgICAgICBuZXh0RGVsYXksXG4gICAgICAgIG5leHRBdHRlbXB0OiBhdHRlbXB0ICsgMSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsYmFjayBvcGNpb25hbFxuICAgICAgaWYgKG9wdHMub25SZXRyeSkge1xuICAgICAgICBvcHRzLm9uUmV0cnkobGFzdEVycm9yLCBhdHRlbXB0LCBuZXh0RGVsYXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZ3VhcmRhciBhbnRlcyBkbyBwcsOzeGltbyByZXRyeVxuICAgICAgYXdhaXQgc2xlZXAobmV4dERlbGF5KTtcblxuICAgICAgLy8gQXR1YWxpemFyIGRlbGF5IHBhcmEgcHLDs3hpbWEgaXRlcmHDp8Ojb1xuICAgICAgZGVsYXkgPSBNYXRoLm1pbihkZWxheSAqIG9wdHMuYmFja29mZkZhY3Rvciwgb3B0cy5tYXhEZWxheSk7XG4gICAgfVxuICB9XG5cbiAgLy8gTnVuY2EgZGV2ZSBjaGVnYXIgYXF1aSwgbWFzIFR5cGVTY3JpcHQgcHJlY2lzYVxuICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKGAke2NvbnRleHR9OiBSZXRyeSBmYWlsZWRgKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhIGRlbGF5IGNvbSBleHBvbmVudGlhbCBiYWNrb2ZmIGUgaml0dGVyIG9wY2lvbmFsXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbGF5KGN1cnJlbnREZWxheTogbnVtYmVyLCBvcHRpb25zOiBSZXRyeU9wdGlvbnMpOiBudW1iZXIge1xuICBsZXQgbmV4dERlbGF5ID0gY3VycmVudERlbGF5O1xuXG4gIC8vIEFkaWNpb25hciBqaXR0ZXIgKGFsZWF0b3JpZWRhZGUpIHNlIGhhYmlsaXRhZG9cbiAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgLy8gSml0dGVyIGVudHJlIDUwJSBlIDE1MCUgZG8gZGVsYXlcbiAgICBjb25zdCBqaXR0ZXJGYWN0b3IgPSAwLjUgKyBNYXRoLnJhbmRvbSgpO1xuICAgIG5leHREZWxheSA9IE1hdGguZmxvb3IoY3VycmVudERlbGF5ICogaml0dGVyRmFjdG9yKTtcbiAgfVxuXG4gIC8vIEdhcmFudGlyIHF1ZSBuw6NvIGV4Y2VkZSBtYXhEZWxheVxuICByZXR1cm4gTWF0aC5taW4obmV4dERlbGF5LCBvcHRpb25zLm1heERlbGF5KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgcGFyYSBhZ3VhcmRhciB1bSB0ZW1wb1xuICovXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBWZXJpZmljYSBzZSB1bSBlcnJvIMOpIHJldHJ5YWJsZSAodGVtcG9yw6FyaW8pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JldHJ5YWJsZUVycm9yKGVycm9yOiBFcnJvcik6IGJvb2xlYW4ge1xuICBjb25zdCByZXRyeWFibGVQYXR0ZXJucyA9IFtcbiAgICAvRUNPTk5SRUZVU0VEL2ksXG4gICAgL0VUSU1FRE9VVC9pLFxuICAgIC9FTk9URk9VTkQvaSxcbiAgICAvRUhPU1RVTlJFQUNIL2ksXG4gICAgL0VORVRVTlJFQUNIL2ksXG4gICAgL3RpbWVvdXQvaSxcbiAgICAvY29ubmVjdGlvbi4qY2xvc2VkL2ksXG4gICAgL2Nvbm5lY3Rpb24uKnJlc2V0L2ksXG4gICAgL3NvY2tldCBoYW5nIHVwL2ksXG4gIF07XG5cbiAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgcmV0dXJuIHJldHJ5YWJsZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoZXJyb3JNZXNzYWdlKSk7XG59XG5cbi8qKlxuICogUmV0cnkgYXBlbmFzIHBhcmEgZXJyb3MgcmV0cnlhYmxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeU9uUmV0cnlhYmxlRXJyb3I8VD4oXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBvcHRpb25zOiBQYXJ0aWFsPFJldHJ5T3B0aW9ucz4gPSB7fSxcbiAgY29udGV4dDogc3RyaW5nID0gJ09wZXJhdGlvbidcbik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gcmV0cnlXaXRoQmFja29mZihcbiAgICBmbixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgb25SZXRyeTogKGVycm9yLCBhdHRlbXB0LCBkZWxheSkgPT4ge1xuICAgICAgICAvLyBTw7MgcmV0cnkgc2UgZm9yIGVycm8gcmV0cnlhYmxlXG4gICAgICAgIGlmICghaXNSZXRyeWFibGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gTGFuw6dhIGltZWRpYXRhbWVudGUgc2UgbsOjbyBmb3IgcmV0cnlhYmxlXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vblJldHJ5Py4oZXJyb3IsIGF0dGVtcHQsIGRlbGF5KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBjb250ZXh0XG4gICk7XG59Il0sInZlcnNpb24iOjN9